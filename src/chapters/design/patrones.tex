\sect{Patrones de diseño}{design-patterns}

\textit{Un patrón de diseño es una solución que se puede aplicar a diferentes contextos y que se
puede reutilizar en diferentes proyectos.} \\
Hay varias categorías de patrones de diseño, cada una con una finalidad diferente:
\begin{itemize}
	\item \textbf{Patrones de creación}: se utilizan para crear objetos.
	\item \textbf{Patrones estructurales}: se utilizan para estructurar objetos.
	\item \textbf{Patrones de comportamiento}: se utilizan para definir la interacción entre objetos.
\end{itemize}
\label{itm:categorías-patrones}

En este proyecto se han utilizado varios patrones de diseño, para permitir una mejor escalabilidad, mantenibilidad y
reutilización del código.\ A continuación se detalla cierta información de los patrones utilizados:
\begin{itemize}
	\item Definición / categoría.
	\item Explicación de cómo se ha implementado en el proyecto.
	\item Diagrama UML\@.
	\item Justificación de su uso en la aplicación.
\end{itemize}
\label{itm:uso-patrones}

\subsect{Builder}{builder}
Es un patrón de \bold{creación} que permite instanciar objetos complejos de una forma sencilla.\ Se ha creado una
interfaz \mono{Builder} genérica para su reutilización en caso de ser necesaria.\ Esta interfaz define el
método \mono{build()} que devolverá la instancia de un objeto con los datos establecidos previamente.

\begin{center}
	\begin{tikzpicture}
		\umlinterface[x=8]{Builder}{}{
			+ build(): Object
		}{}
		\umlclass[y=-5]{JsonMessageWrapper}{
			-- rawPayload: String \\
			-- parsedPayload: JsonObject
		}{
			...
		}{}
		\umlclass[y=-5,x=8]{BuilderImpl}{
			-- headers: JsonObject \\
			-- body: JsonObject
		}{
			+ build(): Object
		}{}

		\umlnest{JsonMessageWrapper}{BuilderImpl}
		\umlimpl{BuilderImpl}{Builder}
	\end{tikzpicture}
\end{center}

En este proyecto se ha usado para simplificar la creación de objetos de tipo \mono{JsonMessageWrapper}, por el
momento.\ Esta clase es la encargada de encapsular los mensajes que se envían a través de la red en formato JSON\@.


\subsect{Singleton}{singleton}
Este patrón se utiliza para garantizar que una clase tenga una única instancia y proporciona un punto de acceso
global a ella~\cite{sarcar2018java}.\ En el contexto de esta aplicación, se utiliza en ciertas
clases de utilidad y en las clases que asocian rutas a un método HTTP (por ejemplo \mono{/login} con el método POST).
Estas últimas son clases internas de \mono{Routes.java} y los nombres dependen del método HTTP que se debe utilizar para
realizar una petición a una ruta específica.

\begin{table}[ht]
	\centering
	\caption{Relación entre método HTTP y ruta.}
	\label{tab:routes}
	\begin{tabular}{|c|c|}
		\hline
		Método HTTP & Clase de la ruta   \\
		\hline
		GET           & \mono{GetRoute}    \\
		POST          & \mono{PostRoute}   \\
		PUT           & \mono{PutRoute}    \\
		DELETE        & \mono{DeleteRoute} \\
		\hline
	\end{tabular}
\end{table}

Se han utilizado diferentes formas de acceso a la instancia de las clases.\ En el caso de las clases que asocian rutas a
métodos HTTP, el modificador de acceso a la instancia es público.\ En otros casos, se provee un método estático para
obtener la instancia de la clase, como se muestra en el siguiente ejemplo:

\begin{codeBlock}
	\begin{minted}[fontsize=\footnotesize,baselinestretch=1.1,tabsize=4]{java}
public class Routes {
	private Routes() {}
	...
	public static class GetRoute {
		public static final GetRoute INSTANCE = new GetRoute();

		private GetRoute() {}

		public static final String USERS_URL = V_1 + "/users";

		/* Array containing the routes allowed by the low tier user */
		public String[] lowTierRoutes() {...}

		/* Array containing the routes allowed by the medium tier user */
		public String[] mediumTierRoutes() {...}

		/* Array containing the routes allowed by the top tier user */
		public String[] topTierRoutes() {...}
	}
	...
}
	\end{minted}

	\caption{Rutas utilizadas para simplificar el proceso de autorización de los usuarios.}
\end{codeBlock}

\subsect{Strategy}{strategy}
\lipsum
