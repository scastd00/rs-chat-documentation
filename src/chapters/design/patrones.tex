\sect{Patrones de diseño}{design-patterns}

\textit{Un patrón de diseño es una solución que se puede aplicar a diferentes contextos y que se
puede reutilizar en diferentes proyectos.} \\
Hay varias categorías de patrones de diseño, cada una con una finalidad diferente:
\begin{itemize}
	\item \textbf{Patrones de creación}: se utilizan para crear objetos.
	\item \textbf{Patrones estructurales}: se utilizan para estructurar objetos.
	\item \textbf{Patrones de comportamiento}: se utilizan para definir la interacción entre objetos.
\end{itemize}
\label{itm:categorías-patrones}

En este proyecto se han utilizado varios patrones de diseño, para permitir una mejor escalabilidad, mantenibilidad y
reutilización del código.\ A continuación se detalla cierta información de los patrones utilizados:
\begin{itemize}
	\item Definición / categoría.
	\item Explicación de cómo se ha implementado en el proyecto.
	\item Diagrama UML\@.
	\item Justificación de su uso en la aplicación.
\end{itemize}
\label{itm:uso-patrones}

\subsect{Builder}{builder}
Es un patrón de \boldFont{creación} que permite instanciar objetos complejos de una forma sencilla.\ Se ha creado una
interfaz (\monoFont{Builder}) genérica para su reutilización en caso de ser necesaria para cualquier otra clase.
Esta interfaz define el método \monoFont{build()} que devolverá la instancia de un objeto con los datos establecidos
previamente.\ El diagrama UML del patrón implementado es el siguiente:

\begin{umlDiagram}
	\centering
	\begin{tikzpicture}
		\umlinterface[x=-8,y=2]{Builder}{}{
			+ build(): Object
		}{}
		\umlclass[y=-1]{JsonMessageWrapper}{
			-- rawPayload: String \\
			-- parsedPayload: JsonObject
		}{
			+ getRawPayload(): String \\
			+ getParsedPayload(): JsonObject \\
			+ headers(): JsonObject \\
			+ body(): JsonObject \\
			+ username(): String \\
			+ chatId(): String \\
			+ sessionId(): long \\
			+ type(): String \\
			+ date(): long \\
			+ token(): String \\
			+ content(): String \\
			+ builder(): BuilderImpl
		}{}
		\umlclass[x=-8,y=-3]{BuilderImpl}{
			-- headers: JsonObject \\
			-- body: JsonObject
		}{
			+ username(String): BuilderImpl \\
			+ chatId(String): BuilderImpl \\
			+ sessionId(long): BuilderImpl \\
			+ type(String): BuilderImpl \\
			+ date(long): BuilderImpl \\
			+ token(String): BuilderImpl \\
			+ content(String): BuilderImpl
		}{}

		\umlnest{JsonMessageWrapper}{BuilderImpl}
		\umlimpl{BuilderImpl}{Builder}
	\end{tikzpicture}

	\caption{Diagrama UML del patrón Builder empleado en la aplicación.}
\end{umlDiagram}

El patrón builder se ha usado en la aplicación para simplificar la creación de objetos de tipo
\monoFont{JsonMessageWrapper}, por el
momento.\ Esta clase es la encargada de encapsular los mensajes que se envían a través de la red en formato JSON\@.


\subsect{Singleton}{singleton}
También es un patrón de creación y se emplea para garantizar que una clase concreta tenga una única instancia y
proporciona un punto de acceso global a ella~\cite{sarcar2018java}.\ En el contexto de esta aplicación, se utiliza en
ciertas clases de utilidad y en las clases que asocian rutas a un método HTTP (por ejemplo \monoFont{/login} con el
método POST).\ Estas últimas son clases internas de \monoFont{Routes.java} y los nombres dependen del método HTTP que
se debe utilizar para realizar una petición a una ruta específica.

\begin{table}[H]
	\centering
	\caption{Relación entre método HTTP y ruta.}
	\label{tab:routes}
	\begin{tabular}{|c|c|}
		\hline
		Método HTTP & Clase de la ruta       \\
		\hline
		GET           & \monoFont{GetRoute}    \\
		POST          & \monoFont{PostRoute}   \\
		PUT           & \monoFont{PutRoute}    \\
		DELETE        & \monoFont{DeleteRoute} \\
		\hline
	\end{tabular}
\end{table}

\begin{umlDiagram}
	\centering
	\begin{tikzpicture}
		\umlclass{Routes}{
			-- V\_1: String = \str{/api/v1} \\
			+ ROOT\_URL: String = \str{/} \\
			+ ALL\_ROUTES: String = \str{/**} \\
			+ REFRESH\_TOKEN\_URL: String = \str{/api/v1/token/refresh} \\
			+ WS\_CHAT\_ENDPOINT: String = \str{/ws/rschat}
		}{}{}
	\end{tikzpicture}

	\caption{Diagrama UML del patrón Singleton empleado en la aplicación.}
\end{umlDiagram}

Se han utilizado diferentes formas de acceso a la instancia de las clases.\ En el caso de las clases que asocian rutas a
métodos HTTP, el modificador de acceso a la instancia es público.\ En otros casos, se provee un método estático para
obtener la instancia de la clase, como se muestra en el siguiente ejemplo:

\begin{codeBlock}
	\begin{minted}[fontsize=\footnotesize,baselinestretch=1.1,tabsize=4]{java}
public class Routes {
	private Routes() {}
	...
	public static class GetRoute {
		public static final GetRoute INSTANCE = new GetRoute();

		private GetRoute() {}

		public static final String USERS_URL = V_1 + "/users";

		/* Array containing the routes allowed by the low tier user */
		public String[] lowTierRoutes() {...}

		/* Array containing the routes allowed by the medium tier user */
		public String[] mediumTierRoutes() {...}

		/* Array containing the routes allowed by the top tier user */
		public String[] topTierRoutes() {...}
	}
	...
}
	\end{minted}

	\caption{Rutas utilizadas para simplificar el proceso de autorización de los usuarios.}
\end{codeBlock}

\subsect{Strategy}{strategy}
\lipsum
