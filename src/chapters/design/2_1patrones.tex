\sect{Patrones de diseño}{design-patterns}

\textit{Un patrón de diseño es una solución que se puede aplicar a diferentes contextos y que se
puede reutilizar en diferentes proyectos.} \\
Hay varias categorías de patrones de diseño, cada una con una finalidad diferente\cite{designPatternClassification}:
\begin{itemize}
	\item \textbf{Patrones de creación}: se utilizan para crear objetos de una forma flexible y reutilizando código
	existente.
	\item \textbf{Patrones estructurales}: se utilizan para convertir clases y objetos en estructuras más complejas.
	\item \textbf{Patrones de comportamiento}: se utilizan para definir la interacción entre objetos.
\end{itemize}
\label{itm:categorías-patrones}

En este proyecto se han utilizado varios patrones de diseño, para permitir una mejor escalabilidad, mantenibilidad y
reutilización del código.\ A continuación se detalla cierta información de los patrones utilizados:
\begin{itemize}
	\item Definición / categoría.
	\item Explicación de cómo se ha implementado en el proyecto.
	\item Diagrama UML\@.
	\item Justificación de su uso en la aplicación.
\end{itemize}
\label{itm:uso-patrones}

\subsect{Builder}{builder}
Es un patrón de \boldFont{creación} que permite instanciar objetos complejos de una forma sencilla.\ Se ha creado una
interfaz (\monoFont{Builder}) genérica para su reutilización en caso de ser necesaria para cualquier otra clase.
Esta interfaz define el método \monoFont{build()} que devolverá la instancia de un objeto con los datos establecidos
previamente.\ El diagrama UML del patrón implementado es el siguiente:

\begin{umlDiagram}
	\centering
	\begin{tikzpicture}
		\umlinterface[x=-8,y=2]{Builder}{}{
			+ build(): Object
		}{}
		\umlclass[y=-1]{JsonMessageWrapper}{
			-- rawPayload: String \\
			-- parsedPayload: JsonObject
		}{
			+ getRawPayload(): String \\
			+ getParsedPayload(): JsonObject \\
			+ headers(): JsonObject \\
			+ body(): JsonObject \\
			+ username(): String \\
			+ chatId(): String \\
			+ sessionId(): long \\
			+ type(): String \\
			+ date(): long \\
			+ token(): String \\
			+ content(): String \\
			+ builder(): BuilderImpl
		}{}
		\umlclass[x=-8,y=-3]{BuilderImpl}{
			-- headers: JsonObject \\
			-- body: JsonObject
		}{
			+ username(String): BuilderImpl \\
			+ chatId(String): BuilderImpl \\
			+ sessionId(long): BuilderImpl \\
			+ type(String): BuilderImpl \\
			+ date(long): BuilderImpl \\
			+ token(String): BuilderImpl \\
			+ content(String): BuilderImpl
		}{}

		\umlnest{JsonMessageWrapper}{BuilderImpl}
		\umlimpl{BuilderImpl}{Builder}
	\end{tikzpicture}

	\caption{Patrón Builder empleado en la aplicación.}
\end{umlDiagram}

El patrón builder se ha usado en la aplicación para simplificar la creación de objetos de tipo
\monoFont{JsonMessageWrapper}, por el
momento.\ Esta clase es la encargada de encapsular los mensajes que se envían a través de la red en formato JSON\@.


\subsect{Singleton}{singleton}
También es un patrón de \boldFont{creación} y se emplea para garantizar que una clase concreta tenga una única
instancia y
proporciona un punto de acceso global a ella~\cite{sarcar2018java}.\ En el contexto de esta aplicación, se utiliza en
ciertas clases de utilidad y en las clases que asocian rutas a un método HTTP (por ejemplo \monoFont{/login} con el
método POST).\ Estas últimas son clases internas de \monoFont{Routes.java} y los nombres dependen del método HTTP que
se debe utilizar para realizar una petición a una ruta específica.

\begin{table}[H]
	\centering
	\caption{Relación entre método HTTP y ruta.}
	\label{tab:routes}
	\begin{tabular}{|c|c|}
		\hline
		Método HTTP & Clase de la ruta       \\
		\hline
		GET           & \monoFont{GetRoute}    \\
		POST          & \monoFont{PostRoute}   \\
		PUT           & \monoFont{PutRoute}    \\
		DELETE        & \monoFont{DeleteRoute} \\
		\hline
	\end{tabular}
\end{table}

\begin{umlDiagram}
	\centering
	\scalebox{0.8} {
		\begin{tikzpicture}
			\umlclass{Routes}{
				\umlstatic{-- V\_1: String = \str{/api/v1}} \\
				\umlstatic{+ ROOT\_URL: String = \str{/}} \\
				\umlstatic{+ ALL\_ROUTES: String = \str{/**}} \\
				\umlstatic{+ REFRESH\_TOKEN\_URL: String = \str{/api/v1/token/refresh}} \\
				\umlstatic{+ WS\_CHAT\_ENDPOINT: String = \str{/ws/rschat}}
			}{}{}

			\umlclass[x=-4,y=5]{GetRoute}{
				\umlstatic{+ INSTANCE: GetRoute}
			}{
				+ lowTierRoutes(): String[] \\
				+ mediumTierRoutes(): String[] \\
				+ topTierRoutes(): String[]
			}{}
			\umlclass[x=4,y=5]{PostRoute}{
				\umlstatic{+ INSTANCE: PostRoute}
			}{
				+ lowTierRoutes(): String[] \\
				+ mediumTierRoutes(): String[] \\
				+ topTierRoutes(): String[]
			}{}
			\umlclass[x=-4,y=-5]{PutRoute}{
				\umlstatic{+ INSTANCE: PutRoute}
			}{
				+ lowTierRoutes(): String[] \\
				+ mediumTierRoutes(): String[] \\
				+ topTierRoutes(): String[]
			}{}
			\umlclass[x=4,y=-5]{DeleteRoute}{
				\umlstatic{+ INSTANCE: DeleteRoute}
			}{
				+ lowTierRoutes(): String[] \\
				+ mediumTierRoutes(): String[] \\
				+ topTierRoutes(): String[]
			}{}

			\umlnest{Routes}{GetRoute}
			\umlnest{Routes}{PostRoute}
			\umlnest{Routes}{PutRoute}
			\umlnest{Routes}{DeleteRoute}
		\end{tikzpicture}
	}

	\caption{Patrón Singleton empleado en la aplicación.}
\end{umlDiagram}

Se han utilizado diferentes formas de acceso a la instancia de las clases.\ En el caso de las clases que asocian rutas a
métodos HTTP, el modificador de acceso a la instancia es público.\ En otros casos, se provee un método estático para
obtener la instancia de la clase, como se muestra en el siguiente ejemplo:

\begin{codeBlock}
	\begin{minted}[fontsize=\footnotesize,baselinestretch=1.1,tabsize=4]{java}
public class Routes {
	private Routes() {}
	...
	public static class GetRoute {
		public static final GetRoute INSTANCE = new GetRoute();

		private GetRoute() {}

		public static final String USERS_URL = V_1 + "/users";

		/* Array containing the routes allowed by the low tier user */
		public String[] lowTierRoutes() {...}

		/* Array containing the routes allowed by the medium tier user */
		public String[] mediumTierRoutes() {...}

		/* Array containing the routes allowed by the top tier user */
		public String[] topTierRoutes() {...}
	}
	...
}
	\end{minted}

	\caption{Rutas utilizadas para simplificar el proceso de autorización de los usuarios.}
\end{codeBlock}

{\Huge Todo: Quitar el código y dejar solo el diagrama}

\subsect{Strategy}{strategy}
Este patrón de \boldFont{comportamiento} se utiliza para encapsular un algoritmo dentro de una clase, de forma que
pueda ser intercambiado por otro algoritmo en tiempo de ejecución.\ En la aplicación, se emplea para encapsular el
proceso de manejo de los mensajes que se envían entre los usuarios.\ Existen varias clases que se encargan de
realizarlo, por lo que todas ellas implementan la interfaz \monoFont{MessageStrategy}, que define el método
\monoFont{handle(...)}, encargado de realizar el procesamiento del mensaje y recibe 3 parámetros:

\begin{itemize}
	\item El mensaje que se debe manejar.
	\item La lista con todos los chats para determinar al que se debe enviar el mensaje.
	\item Otros datos que pueden ser necesarios para el manejo del mensaje.\ Dependiendo de la clase, este parámetro
	puede contener más o menos datos.
\end{itemize}
\label{itm:parametershandlestrategy}

Las clases que implementan esta interfaz son las siguientes:

\begin{itemize}
	\item \monoFont{ActiveUsersStrategy}
	\item \monoFont{ErrorMessageStrategy}
	\item \monoFont{GenericMessageStrategy} - De la cual heredan:
	\begin{itemize}
		\item \monoFont{AudioMessageStrategy}
		\item \monoFont{ImageMessageStrategy}
		\item \monoFont{TextMessageStrategy}
		\item \monoFont{VideoMessageStrategy}
	\end{itemize}
	\item \monoFont{GetHistoryStrategy}
	\item \monoFont{PingStrategy}
	\item \monoFont{UserJoinedStrategy}
	\item \monoFont{UserLeftStrategy}
\end{itemize}
\label{itm:strategies}

A continuación se muestra el diagrama UML de la interfaz \monoFont{MessageStrategy}

\begin{umlDiagram}
	\centering
	\begin{tikzpicture}
		\umlinterface[x=0,y=0]{MessageStrategy}{
			+ handle(JsonMessageWrapper, WebSocketChatMap, Map<String, Object>): void
		}{}
	\end{tikzpicture}

	\caption{Interfaz MessageStrategy.}
\end{umlDiagram}

Este patrón se ha utilizado para simplificar el manejo de los mensajes recibidos en el servidor y para que sea más
fácil de extender.\ En el caso de que se desee agregar un nuevo tipo de mensaje, se debe crear una nueva clase que
implemente la interfaz \monoFont{MessageStrategy} y agregarla a la lista de estrategias que se encuentran en la
clase \monoFont{WebSocketHandler}.\ Esta clase es la encargada de determinar qué estrategia se debe utilizar para
manejar el mensaje.\ Para esto, se utiliza el método \monoFont{decideStrategy(receivedMessageType: WSMessage)} que
recibe como parámetro el tipo mensaje y devuelve la estrategia que se debe utilizar para manejar el mensaje.
