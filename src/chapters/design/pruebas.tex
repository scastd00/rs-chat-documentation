En un proyecto software, las pruebas son una parte fundamental del desarrollo, ya que garantiza que el software funciona
correctamente y se comporta como se espera.\ Además, se asegura que el software no se rompe al añadir nuevas
funcionalidades o al modificar las existentes.\ Existen varios tipos de pruebas, dependiendo del nivel de abstracción
al que se realicen.\ En este proyecto se han implementado pruebas unitarias y de integración.

\subsect{Pruebas unitarias}{pruebas-unitarias}

Las pruebas unitarias son aquellas que se realizan sobre la unidad más pequeña de código, que en el caso de este
proyecto son los métodos.\ Se dividen en dos tipos:

\subsubsect{Pruebas de caja blanca}{pruebas-caja-blanca}

Las pruebas unitarias de caja blanca son un método de diseño de casos de prueba que se basa en la estructura interna
del código a probar.\ Se centra en la cobertura de las rutas de ejecución del código, es decir, se comprueba que se
ejecuta cada línea de código al menos una vez.\ Para ello, se realizan diagramas de control flujo de los métodos y se
analiza la \boldFont{complejidad ciclomática}, que es una medida de la complejidad de un programa de
ordenador.\ Este tipo de grafo es dirigido, en el que los
nodos representan grupos de instrucciones y las aristas las posibles rutas de ejecución.\ La complejidad ciclomática
se puede calcular mediante 3 ecuaciones diferentes, que son equivalentes:

\begin{center}
	\begin{equation}
		C = R
		\label{eq:complejidad-ciclomatica-1}
	\end{equation}

	\begin{equation}
		C = E - N + 2
		\label{eq:complejidad-ciclomatica-2}
	\end{equation}

	\begin{equation}
		C = D + 1
		\label{eq:complejidad-ciclomatica-3}
	\end{equation}
\end{center}

Donde:
\begin{itemize}
	\item $C$ es la complejidad ciclomática.
	\item $R$ es el número de regiones.
	\item $E$ es el número de aristas.
	\item $N$ es el número de nodos.
	\item $D$ es el número de sentencias de decisión.
\end{itemize}

Cuanto mayor sea la complejidad, más difícil será probar el código y es más probable que contenga errores.
Por ello, se recomienda que la complejidad ciclomática sea menor o igual que 10, para que sea más fácil de
probar~\cite{Cyclomat84:online}.\ A continuación, se muestran las pruebas unitarias de caja blanca
realizadas para un método que tiene sentencias iterativas y condicionales:

\begin{codeBlock}
	\begin{minted}[
		baselinestretch=1.1,
		fontsize=\footnotesize,
		tabsize=2,
	]{java}
				public double probabilityOfClass(NSFWClass nsfwClass) {
					double probability = 0.0;

					for (NSFWClass value : NSFWClass.values()) {
						String predictionName = value.name().toLowerCase();
						probability = this.predictions.get(predictionName).getAsDouble();

						if (value.equals(nsfwClass)) {
							break;
						}
					}

					return probability;
				}
	\end{minted}
	\caption{Método para determinar la clase NSFW asociada a una imagen.}
\end{codeBlock}
\label{cod:codigo-pruebas-unitarias-caja-blanca}

El análisis de la complejidad ciclomática quedaría de la siguiente forma:

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[
		node distance = 1.5cm,
		auto,
		font=\scriptsize,
		every state/.style={circle, draw, minimum size=5mm}
	]
		\node (q1) [state, initial] {$1 \left( hasNext \right)$};
		\node (q2) [state, right = of q1] {$2 \left(for\right)$};
		\node (q3) [state, below right = of q2] {$3$};
		\node (q4) [state, below = of q3] {$4 \left(if\right)$};
		\node (q5) [state, below = of q4, accepting] {$5$};

		\node (r1) [state, right = of q3, draw=none, text=blue] {$\underline{R_1}$};
		\node (r3) [state, left = of q4, draw=none, text=blue] {$\underline{R_3}$};

		\path [-stealth]
		(q1) edge node [text=green!60!black] {$true$} (q2)
		(q1) edge [bend right = 40] node [text=red!60!black, swap] {$false$} (q5)
		(q2) edge node {} (q3)
		(q2) edge [draw=none, bend right=15, text=blue] node {$\underline{R_2}$} (q4)
		(q3) edge node {} (q4)
		(q4) edge node [text=green!60!black] {$true$} (q5)
		(q4) edge [bend left] node [text=red!60!black] {$false$} (q2);

	\end{tikzpicture}
	\caption{Grafo de control de flujo del método \monoFont{probabilityOfClass}.}
	\label{fig:grafo-control-flujo-pruebas-unitarias-caja-blanca}
\end{figure}

Los resultados para cada ecuación son los siguientes:

\begin{itemize}
	\item Ecuación~\ref{eq:complejidad-ciclomatica-1}: $= 3$
	\item Ecuación~\ref{eq:complejidad-ciclomatica-2}: $= 6 - 5 + 2 = 3$
	\item Ecuación~\ref{eq:complejidad-ciclomatica-3}: $= 2 + 1 = 3$
\end{itemize}

Como se puede observar, el método tiene una complejidad ciclomática de 3, por lo que es fácil de probar.\ Ahora se
procede a realizar los casos de prueba para que cada línea de código se ejecute al menos una vez:

\begin{enumerate}
	\item \boldFont{Camino 1}: $1 \rightarrow 5$.
	\\
	\underline{Aristas cubiertas}: $1 \rightarrow 5$.\\
	\underline{Condición}: El enumerado \monoFont{NSFWClass} está vacío.\\
	\underline{Caso de prueba}: \monoFont{nsfwClass} $=$ \monoFont{null}.\\
	\underline{Descripción}:
	Debido a que el enumerado está vacío, no se entra en el bucle y se devuelve el valor por defecto de la variable
	\monoFont{probability}, que es $0.0$.

	\item \boldFont{Camino 2}: $1 \rightarrow 2 \rightarrow 3 \rightarrow 4 \rightarrow 5$.
	\\
	\underline{Aristas cubiertas}: $1 \rightarrow 2$, $2 \rightarrow 3$, $3 \rightarrow 4$, $4 \rightarrow 5$.\\
	\underline{Condición}: \monoFont{nsfwClass.name} $=$ \monoFont{value.name}.\\
	\underline{Caso de prueba}: \monoFont{nsfwClass} $=$ \monoFont{NSFWClass.NEUTRAL}.\\
	\underline{Descripción}:
	El valor del parámetro del método es igual al primer valor del enumerado,
	por lo que se ejecuta la rama \monoFont{true} del condicional y se sale del bucle en la primera iteración.

	\item \boldFont{Camino 3}: $1 \rightarrow 2 \rightarrow 3 \rightarrow 4 \rightarrow 2 \rightarrow 3 \rightarrow 4 \rightarrow 5$.
	\\
	\underline{Nueva arista cubierta}: $4 \rightarrow 2$.\\
	\underline{Condición}: \monoFont{nsfwClass.name} $\neq$ \monoFont{value.name}.\\
	\underline{Caso de prueba}: \monoFont{nsfwClass} $=$ \monoFont{NSFWClass.DRAWINGS}.\\
	\underline{Descripción}:
	El valor del parámetro del método es distinto al primer valor del
	enumerado (en este caso es el segundo), por lo que se ejecuta la rama \monoFont{false} del condicional y se
	vuelve a ejecutar el bucle, saliendo en la segunda iteración.
\end{enumerate}
\label{itm:casos-prueba-pruebas-unitarias-caja-blanca}

\subsubsect{Pruebas de caja negra}{pruebas-caja-negra}

Las pruebas de caja negra son aquellas que se enfocan en la funcionalidad del programa, sin tener en cuenta su
implementación interna.\ Para ello, se diseñan casos de prueba que cubran todas las posibles
\boldFont{entradas y salidas} del programa.
La realización de estas pruebas conlleva la creación de un conjunto de datos de prueba, que se
organizan en \boldFont{clases de equivalencia} (o particiones de equivalencia) y
\boldFont{condiciones límite}.\ En este caso, se han diseñado los casos de
prueba usando la técnica de particiones de equivalencia, que consiste en dividir el conjunto de datos de entrada en
subconjuntos de datos de entrada válidos e inválidos, de tal forma que se garantice que todos los casos de prueba
se validan una vez.\ A continuación, se muestran las clases de equivalencia definidas para la funcionalidad de
consultar los emojis en función de su nombre:

\begin{table}[H]
	\centering
	\caption{Definición de las clases de equivalencia.}
	\begin{adjustbox}{width=\textwidth}
		\begin{tabular}{|c|c|c|c|c|c|c|}
			\hline
			\multirow{2}{*}{\boldFont{Sec.}} & \multirow{2}{*}{\begin{tabular}[c]{@{}c@{}}
																   \boldFont{Condición}\\ \boldFont{de entrada}
			\end{tabular}} & \multirow{2}{*}{\boldFont{Tipo}} & \multicolumn{2}{c|}{\boldFont{Clases válidas}} & \multicolumn{2}{c|}{
				\boldFont{Clases No Válidas}} \\ \cline{4-7}
			& &        & \textit{Entrada} & \textit{Código}           & \textit{Entrada} & \textit{Código} \\ \hline
			& & Lógico & Cadena vacía     & CEV\textless1\textgreater &                  &                 \\ \cline{
				3-7}
			\multirow{2}{*}{1} & \multirow{2}{*}{Nombre de emoji} & \multirow{3}{*}{Si está, es Valor} &
			Cadena con caracteres válidos & CEV\textless2\textgreater & \begin{tabular}[c]{@{}c@{}}
																			Cadena con caracteres válidos pero \\ no
																			existe en base de datos
			\end{tabular} & CENV\textless1\textgreater \\ \cline{4-7}
			& & & & & \begin{tabular}[c]{@{}c@{}}
						  Cadena con caracteres no\\ soportados (números, /, ?, !, etc.)
			\end{tabular} & CENV\textless2\textgreater \\ \hline
		\end{tabular}
	\end{adjustbox}
	\label{tab:clases-equivalencia-caja-negra}
\end{table}

\begin{table}[H]
	\centering
	\caption{Casos de prueba para la funcionalidad de consultar emojis por nombre.}
	\begin{adjustbox}{width=\textwidth}
		\begin{tabular}{|c|c|c|c|}
			\hline
			\multirow{2}{*}{\boldFont{ID CP}} & \multirow{2}{*}{\boldFont{Escenario}} & \boldFont{Condiciones de
			entrada} & \multirow{2}{*}{\boldFont{Resultado esperado}} \\ \cline{3-3}
			& & \textit{Nombre de emoji} & \\ \hline
			CP1 & Escenario 1 & Válida
			& Lista vacía \\ \hline
			CP2 & Escenario 1 & Válida & Lista con emojis cuyo
			nombre contiene la cadena \\ \hline
			CP3 & Escenario 2 & No Válida
			& Lista vacía \\ \hline
			CP4 & Escenario 3 & No Válida & Respuesta HTTP 404 - No
			emojis found \\ \hline
		\end{tabular}
	\end{adjustbox}
	\label{tab:casos-prueba-caja-negra}
\end{table}

\begin{table}[H]
	\centering
	\caption{Valores para los casos de prueba.}
	\begin{adjustbox}{width=\textwidth}
		\begin{tabular}{|c|c|c|c|}
			\hline
			\multirow{2}{*}{\boldFont{ID CP}} & \multirow{2}{*}{\boldFont{Clases de Equivalencia}} & \boldFont{
				Condiciones de entrada} &
			\multirow{2}{*}{\boldFont{Resultado esperado}} \\ \cline{3-3}
			&                           & \textit{Nombre de emoji}              &    \\ \hline
			CP1 & CEV\textless1\textgreater & \textquotedblright \textquotedblright & [] \\ \hline
			CP2 & CEV\textless2\textgreater & \textquotedblright grinning\textquotedblright & [
			\emoji{grinning-cat} ,
			\emoji{grinning-cat-with-smiling-eyes} ,
			\emoji{grinning-face} ,
			\emoji{grinning-face-with-big-eyes} ,
			\emoji{grinning-face-with-smiling-eyes} ,
			\emoji{grinning-face-with-sweat} ,
			\emoji{grinning-squinting-face}
			] \\ \hline
			CP3 & CENV\textless1\textgreater & \textquotedblright emoji\_grin\textquotedblright & 404 - No emojis
			found \\ \hline
			CP4 & CENV\textless2\textgreater & \textquotedblright grin2?\textquotedblright & 404 - No emojis
			found \\ \hline
		\end{tabular}
	\end{adjustbox}
	\label{tab:casos-prueba-caja-negra-con-valores}
\end{table}

\begin{table}[H]
	\centering
	\caption{Nomenclatura utilizada en las tablas de casos de prueba.}
	\begin{tabular}{|c|c|}
		\hline
		\textbf{Código}           & \textbf{Descripción}                 \\ \hline
		CP                          & Caso de prueba                       \\ \hline
		CEV\textless N\textgreater  & Clase de equivalencia válida nº N    \\ \hline
		CENV\textless N\textgreater & Clase de equivalencia no válida nº N \\ \hline
	\end{tabular}
	\label{tab:nomenclatura-casos-prueba-caja-negra}
\end{table}

\subsect{Pruebas de integración}{pruebas-integracion}
% Todo: Pruebas de integración
% Uso mockito...

\subsect{Pruebas de sistema}{pruebas-sistema}
% Todo: Pruebas de sistema, que se han hecho, aunque sea a mano
